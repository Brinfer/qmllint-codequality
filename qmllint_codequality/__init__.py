"""Convert qmllint JSON to Code Quality JSON.

qmllint is a tool shipped with Qt, that verifies the syntactic validity of QML files. It also warns about some
QML anti-patterns.

Developer tools, such as GitLab, can display useful insights about code quality, when given a JSON report file
defined by Code Climate.

This tool converts the JSON report generated by qmllint into a JSON file, as defined by Code Climate.

:Example:

    ```shell
    qmllint --json ./analyse/qmllint.json ./qml/main.qml
    python3 -m qmllint-codequality ./analyse/qmllint.json ./analyse/qmllint.json
    ```

.. seealso::
    - https://codeclimate.com
    - https://doc.qt.io/qt-6/qtquick-tool-qmllint.html
    - https://docs.gitlab.com/ee/ci/testing/code_quality.html#implement-a-custom-tool
"""

import hashlib
import json
import logging
import os
import string
from typing import Optional

from qmllint_codequality import codequality, qmllint

__version__ = "1.0.0"
__project__ = "qmllint-codequality"


VERSION_MESSAGE = f"""
(â˜ž Í¡Â° ÍœÊ– Í¡Â°)â˜ž {__project__} {__version__} ðŸ¦Š
"""
"""The message displayed when using the `qmllint-codequality --version` command."""

logger = logging.getLogger(__name__)


class Diagnostic:
    QMLLINT_LEVEL_TO_CODE_QUALITY_SEVERITY = {
        qmllint.WarningType.INFO: codequality.Severity.INFO,
        qmllint.WarningType.WARNING: codequality.Severity.MAJOR,
        qmllint.WarningType.DISABLE: codequality.Severity.BLOCKER,
    }

    @staticmethod
    def name_to_category(name: str) -> codequality.Category:
        """Determine the Code Quality category of the diagnostic from its name.

        :param name: The name of the diagnostic.
        :type name: str
        :return: The category of the diagnostic.
        :rtype: CodeQualityCategory
        """
        category = codequality.Category.BUG_RISK

        if name in ["MissingType", "UnusedImport", "UnqualifiedAccess"]:
            category = codequality.Category.CLARITY
        elif name in ["MultilineStrings"]:
            category = codequality.Category.STYLE
        elif name in ["InheritanceCycle"]:
            category = codequality.Category.PERFORMANCE
        elif name in ["Deprecated", "NonListProperty"]:
            category = codequality.Category.COMPATIBILITY

        return category

    @staticmethod
    def message_to_name(msg: str) -> str:
        """Determine the name of the diagnostic from the diagnostic message.

        :param msg: The diagnostic's message.
        :type msg: str
        :return: The name of the diagnostic.
        :rtype: str
        """
        normalized_message = msg.lower()

        # Map warning messages to categories
        if "unqualified access" in normalized_message:
            return "Unqualified accesses of properties"

        if "usage of signal handlers" in normalized_message:
            return "Signal handler without matching signal"

        if "usage of with statements" in normalized_message:
            return "Usage of with statements in QML"

        if "issues related to compiling qml code" in normalized_message:
            return "Issues related to compiling QML code"

        if "unused imports" in normalized_message:
            return "Unused imports"

        if "deprecated" in normalized_message:
            return "Deprecated components and properties"

        return "Other"  # Default category for unrecognized warnings

        for warning, splitted in _QMLLINT_WARNING_SPLITTED.items():
            if splitted <= msg_words:
                current_warning = warning
                break

        return f"qmllint[{current_warning}]"

    def __init__(
        self,
        filename: str,
        level: str,
        message: str,
        line: Optional[int] = None,
        column: Optional[int] = None,
        length: Optional[int] = None,
    ) -> None:
        self.__filename = filename
        """File name of the file containing the warning."""

        self.__level: codequality.Severity
        """Severity level of the warning."""

        try:
            self.__level = codequality.Severity[level]
        except KeyError:
            logger.warning("Level '%s' not recognized. Use default value.", level)
            self.__level = codequality.Severity.BLOCKER

        self.__line = line
        """Line in the file where is located the warning."""

        self.__message = message
        """Description of the warning."""

        self.__column = column
        """Column in the file where is located the warning."""

        self.__length = length
        """Number of column where the warning."""

        # Compose the name from the current information
        self.__name = Diagnostic.message_to_name(self.__message)
        """Diagnostic name used for the check name field of the Code Quality JSON."""

        # Compute the category from the name
        self.__category = Diagnostic.name_to_category(self.__name)
        """Code Quality category of the diagnostic."""

        # Compute the fingerprint of the diagnostic
        self.__fingerprint = hashlib.md5(str(self).encode("utf8"), usedforsecurity=False).hexdigest()
        """Unique fingerprint of the diagnostic."""

    def __repr__(self) -> str:
        """Return a string representation of the diagnostic.

        :return: A representation of the diagnostic.
        :rtype: str

        .. seealso:: Diagnostic.__str__
        """
        return f"{str(self)}"

    def __str__(self) -> str:
        """Convert a diagnostic to a string.

        :return: A string representing the diagnostic.
        :rtype: str

        .. seealso:: Diagnostic.__repr__
        """
        return f"{self.__level} at {self.__filename}{f':{self.__line}' if self.__line else ''}{f':{self.__column}' if self.__column else ''}{f':{self.__length}' if self.__length else ''}: {self.__message}"

    def to_code_quality(self) -> codequality.Report:
        """Convert the current diagnostic to the Code Quality format.

        :return: A dictionary representing the Code Quality violation.
        :rtype: dict[str, Union[str, int, list, dict]]
        """
        code_quality: codequality.Report = {
            "type": "issus",
            "severity": self.__level,
            "check_name": f"qmllint[{self.__name}]",
            "description": self.__message,
            "categories": self.__category,
            "fingerprint": self.__fingerprint,
            "location": {"path": self.__filename},
        }

        if self.__line or self.__column:
            position: codequality.LocationPositionBased = {}

            if self.__line:
                position.setdefault("begin", codequality.Position())["lines"] = self.__line

            if self.__column:
                position.setdefault("begin", codequality.Position())["column"] = self.__column

            code_quality["location"]["position"] = position

        return code_quality


def _convert_json(json_input: qmllint.Report) -> tuple[list[codequality.Report], int]:
    """Convert the JSON input into a Code Quality JSON report.

    :param json_input: qmllint JSON report.
    :type json_input: dict
    :return: A list of dictionary, and the number of violation.
    :rtype: tuple[list[dict], int]
    """
    conversion: list[codequality.Report] = []

    # Ensure this JSON report has errors to convert
    if len(json_input) < 1:
        logger.info("Empty JSON imported. Skipping ...")
        return conversion, 0

    for json_file_diagnostic in json_input["files"]:
        filename: str = json_file_diagnostic["filename"]

        if len(json_file_diagnostic["warnings"]) < 1:
            logger.debug("No warning detected in file %s", filename)
            continue

        logger.debug("Processing the warnings of the file %s", filename)

        for json_warning_diagnostic in json_file_diagnostic["warnings"]:
            diagnostic: Diagnostic = Diagnostic(
                filename,
                json_warning_diagnostic["type"],
                json_warning_diagnostic["message"],
                json_warning_diagnostic.get("line"),
                json_warning_diagnostic.get("column"),
                json_warning_diagnostic.get("length"),
            )

            logger.debug("Processed %s", diagnostic)
            conversion.append(diagnostic.to_code_quality())

    return conversion, len(conversion)


def convert_file(input_file_path: str, output_file_path: str) -> int:
    """Convert qmllint JSON file to GitLab-compatible "Code Quality" JSON report.

    :param input_file_path: Input file path (qmllint JSON).
    :type input_file_path: str
    :param output_file_path: Output file path (Code Quality JSON).
    :type output_file_path: str
    :return: If processing failed, a negative value. If successful, number of qmllint issues processed.
    :rtype: int
    """
    # Test if the input file exist
    if not os.path.exists(input_file_path) or not os.path.isfile(input_file_path):
        logger.error("Input file '%s' not found or cannot be opened", input_file_path)
        return -1

    # Parse the input file
    logger.debug("Reading input file: '%s'", input_file_path)

    with open(input_file_path, "rt", encoding="utf8", errors="replace") as in_f:
        conversions, nb_issus = _convert_json(json.load(in_f))

    # Write the output file
    logger.debug("Writing output file: '%s'", output_file_path)

    os.makedirs(os.path.dirname(output_file_path), exist_ok=True)  # Ensure that the destination folder exist

    with open(output_file_path, "w", encoding="utf8") as ou_f:
        json.dump(conversions, ou_f, ensure_ascii=False, indent=None if logger.root.level > logging.DEBUG else 4)

    return nb_issus


if __name__ == "__main__":
    import warnings

    # Warn if this file executed directly. mostly just to catch packaging errors.
    warnings.warn("use 'python3 -m qmllint_codequality', not 'python3 -m qmllint_codequality.__init__'", stacklevel=2)
