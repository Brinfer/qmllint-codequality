"""Convert qmllint JSON to Code Quality JSON.

qmllint is a tool shipped with Qt, that verifies the syntactic validity of QML files. It also warns about some
QML anti-patterns.

Developer tools, such as GitLab, can display useful insights about code quality, when given a JSON report file
defined by Code Climate.

This tool converts the JSON report generated by qmllint into a JSON file, as defined by Code Climate.

:Example:

    ```shell
    qmllint --json ./analyse/qmllint.json ./qml/main.qml
    python3 -m qmllint-codequality ./analyse/qmllint.json ./analyse/qmllint.json
    ```

.. seealso::
    - https://codeclimate.com
    - https://doc.qt.io/qt-6/qtquick-tool-qmllint.html
    - https://docs.gitlab.com/ee/ci/testing/code_quality.html#implement-a-custom-tool
"""

import hashlib
import json
import logging
import os

from qmllint_codequality import codequality, qmllint

__version__ = "1.0.0"
__project__ = "qmllint-codequality"


VERSION_MESSAGE = f"""
(â˜ž Í¡Â° ÍœÊ– Í¡Â°)â˜ž {__project__} {__version__} ðŸ¦Š
"""
"""The message displayed when using the `qmllint-codequality --version` command."""

logger = logging.getLogger(__name__)


class Diagnostic:
    """Diagnostic class converting qmllint diagnostic to CodeQuality report."""

    QMLLINT_LEVEL_TO_CODE_QUALITY_SEVERITY = {
        qmllint.WarningType.INFO: codequality.Severity.INFO,
        qmllint.WarningType.WARNING: codequality.Severity.MAJOR,
        qmllint.WarningType.DISABLE: codequality.Severity.BLOCKER,
    }

    @staticmethod
    def rule_to_category(name: qmllint.Rules) -> codequality.Category:
        """Determine the Code Quality category of the diagnostic from its name.

        :param name: The name of the diagnostic.
        :type name: str
        :return: The category of the diagnostic.
        :rtype: CodeQualityCategory
        """
        category = codequality.Category.BUG_RISK

        if name in [qmllint.Rules.MISSING_TYPE, qmllint.Rules.UNUSED_IMPORTS, qmllint.Rules.UNQUALIFIED_ACCESS]:
            category = codequality.Category.CLARITY
        elif name in [qmllint.Rules.MULTILINE_STRINGS]:
            category = codequality.Category.STYLE
        elif name in [qmllint.Rules.INHERITANCE_CYCLE]:
            category = codequality.Category.PERFORMANCE
        elif name in [qmllint.Rules.DEPRECATED, qmllint.Rules.NON_LIST_PROPERTY]:
            category = codequality.Category.COMPATIBILITY

        return category

    def __init__(
        self,
        filename: str,
        level: qmllint.WarningType,
        message: str,
        line: int | None = None,
        column: int | None = None,
        length: int | None = None,
    ) -> None:
        """Initialize a new Diagnostic object.

        :param filename: The filename containing the warning.
        :type filename: str
        :param level: The qmllint warning level.
        :type level: str
        :param message: The qmllint message.
        :type message: str
        :param line: The line number at the start of the offending code sequence., defaults to None
        :type line: int | None, optional
        :param column: The column number at the start of the offending code sequence., defaults to None
        :type column: int | None, optional
        :param length: The length of the offending code sequence, defaults to None
        :type length: int | None, optional
        """

        self.__filename = filename
        """File name of the file containing the warning."""

        self.__level: codequality.Severity
        """Severity level of the warning."""

        try:
            self.__level = Diagnostic.QMLLINT_LEVEL_TO_CODE_QUALITY_SEVERITY[level]
        except KeyError:
            logger.warning("Level '%s' not recognized. Use default value.", level)
            self.__level = codequality.Severity.BLOCKER

        self.__line = line
        """Line in the file where is located the warning."""

        self.__message = message
        """Description of the warning."""

        self.__column = column
        """Column in the file where is located the warning."""

        self.__length = length
        """Number of column where the warning."""

        # Compose the name from the current information
        self.__name = qmllint.Rules.from_message(self.__message)
        """Diagnostic name used for the check name field of the Code Quality JSON."""

        # Compute the category from the name
        self.__category = Diagnostic.rule_to_category(self.__name)
        """Code Quality category of the diagnostic."""

        # Compute the fingerprint of the diagnostic
        self.__fingerprint = hashlib.md5(str(self).encode("utf8"), usedforsecurity=False).hexdigest()
        """Unique fingerprint of the diagnostic."""

    def __repr__(self) -> str:
        """Return a string representation of the diagnostic.

        :return: A representation of the diagnostic.
        :rtype: str

        .. seealso:: Diagnostic.__str__
        """
        return str(self)

    def __str__(self) -> str:
        """Convert a diagnostic to a string.

        :return: A string representing the diagnostic.
        :rtype: str

        .. seealso:: Diagnostic.__repr__
        """
        string = f"{self.__level} at {self.__filename}"

        if self.__line:
            string += f":{self.__line}"

        if self.__column:
            string += f":{self.__column}"

        if self.__length:
            string += f":{self.__length}"

        string += f": {self.__message}"

        return string

    def to_code_quality(self) -> codequality.Report:
        """Convert the current diagnostic to the Code Quality format.

        :return: A dictionary representing the Code Quality violation.
        :rtype: dict[str, Union[str, int, list, dict]]
        """
        code_quality: codequality.Report = {
            "type": "issus",
            "severity": self.__level,
            "check_name": f"qmllint[{self.__name}]",
            "description": self.__message,
            "categories": self.__category,
            "fingerprint": self.__fingerprint,
            "location": {"path": self.__filename},
        }

        if self.__line or self.__column:
            position: codequality.LocationPositionBased = {}

            if self.__line:
                position.setdefault("begin", {})["lines"] = self.__line

            if self.__column:
                position.setdefault("begin", {})["column"] = self.__column

            code_quality["location"]["position"] = position

        return code_quality


def _convert_json(json_input: qmllint.Report) -> tuple[list[codequality.Report], int]:
    """Convert the JSON input into a Code Quality JSON report.

    :param json_input: qmllint JSON report.
    :type json_input: dict
    :return: A list of dictionary, and the number of violation.
    :rtype: tuple[list[dict], int]
    """
    conversion: list[codequality.Report] = []

    # Ensure this JSON report has errors to convert
    if len(json_input) < 1:
        logger.info("Empty JSON imported. Skipping ...")
        return conversion, 0

    for json_file_diagnostic in json_input["files"]:
        filename: str = json_file_diagnostic["filename"]

        if len(json_file_diagnostic["warnings"]) < 1:
            logger.debug("No warning detected in file %s", filename)
            continue

        logger.debug("Processing the warnings of the file %s", filename)

        for json_warning_diagnostic in json_file_diagnostic["warnings"]:
            diagnostic: Diagnostic = Diagnostic(
                filename,
                json_warning_diagnostic["type"],
                json_warning_diagnostic["message"],
                json_warning_diagnostic.get("line"),
                json_warning_diagnostic.get("column"),
                json_warning_diagnostic.get("length"),
            )

            logger.debug("Processed %s", diagnostic)
            conversion.append(diagnostic.to_code_quality())

    return conversion, len(conversion)


def convert_file(input_file_path: os.PathLike, output_file_path: os.PathLike) -> int:
    """Convert qmllint JSON file to GitLab-compatible "Code Quality" JSON report.

    :param input_file_path: Input file path (qmllint JSON).
    :type input_file_path: os.PathLike
    :param output_file_path: Output file path (Code Quality JSON).
    :type output_file_path: os.PathLike
    :return: If processing failed, a negative value. If successful, number of qmllint issues processed.
    :rtype: int
    """
    # Test if the input file exist
    if not os.path.exists(input_file_path) or not os.path.isfile(input_file_path):
        logger.error("Input file '%s' not found or cannot be opened", input_file_path)
        return -1

    # Parse the input file
    logger.debug("Reading input file: '%s'", input_file_path)

    with open(input_file_path, "rt", encoding="utf8", errors="replace") as in_f:
        conversions, nb_issus = _convert_json(json.load(in_f))

    # Write the output file
    logger.debug("Writing output file: '%s'", output_file_path)

    os.makedirs(os.path.dirname(output_file_path), exist_ok=True)  # Ensure that the destination folder exist

    with open(output_file_path, "w", encoding="utf8") as ou_f:
        json.dump(conversions, ou_f, ensure_ascii=False, indent=None if logger.root.level > logging.DEBUG else 4)

    return nb_issus


if __name__ == "__main__":
    import warnings

    # Warn if this file executed directly. mostly just to catch packaging errors.
    warnings.warn("use 'python3 -m qmllint_codequality', not 'python3 -m qmllint_codequality.__init__'", stacklevel=2)
